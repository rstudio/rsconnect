% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dryRun.R
\name{dryRun}
\alias{dryRun}
\title{Perform a deployment "dry run"}
\usage{
dryRun(
  appDir = getwd(),
  envVars = NULL,
  appFiles = NULL,
  appFileManifest = NULL,
  appPrimaryDoc = NULL,
  contentCategory = NULL,
  quarto = NA
)
}
\arguments{
\item{appDir}{A directory containing an application (e.g. a Shiny app
or plumber API). Defaults to the current directory.}

\item{envVars}{A character vector giving the names of environment variables
whose values should be synchronised with the server (currently supported by
Connect only). The values of the environment variables are sent over an
encrypted connection and are not stored in the bundle, making this a safe
way to send private data to Connect.

The names (not values) are stored in the deployment record so that future
deployments will automatically update their values. Other environment
variables on the server will not be affected. This means that removing an
environment variable from \code{envVars} will leave it unchanged on the server.
To remove it, either delete it using the Connect UI, or temporarily unset
it (with \code{Sys.unsetenv()} or similar) then re-deploy.

Environment variables are set prior to deployment so that your code
can use them and the first deployment can still succeed. Note that means
that if the deployment fails, the values will still be updated.}

\item{appFiles, appFileManifest}{Use \code{appFiles} to specify a
character vector of files to bundle in the app or \code{appManifestFiles}
to provide a path to a file containing a list of such files. If neither
are supplied, will bundle all files in \code{appDir}, apart from standard
exclusions and files listed in a \code{.rscignore} file. See
\code{\link[=listDeploymentFiles]{listDeploymentFiles()}} for more details.}

\item{appPrimaryDoc}{If the application contains more than one document, this
parameter indicates the primary one, as a path relative to \code{appDir}. Can be
\code{NULL}, in which case the primary document is inferred from the contents
being deployed.}

\item{contentCategory}{Set this to \code{"site"} if you'd deploy with
\code{\link[=deploySite]{deploySite()}}; otherwise leave as is.}

\item{quarto}{Should the deployed content be built by quarto?
(\code{TRUE}, \code{FALSE}, or \code{NA}). The default, \code{NA}, will use quarto if
there are \code{.qmd} files in the bundle, or if there is a
\verb{_quarto.yml} and \code{.Rmd} files.

(This option is ignored and quarto will always be used if the
\code{metadata} contains \code{quarto_version} and \code{quarto_engines} fields.)}

\item{verbose}{If TRUE, prints progress messages to the console}
}
\description{
\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#experimental}{\figure{lifecycle-experimental.svg}{options: alt='[Experimental]'}}}{\strong{[Experimental]}}

\code{dryRun()} runs your app locally, attempting to simulate what will happen
when you deploy it on another machine. This isn't a 100\% reliable way of
discovering problems, but it offers a much faster iteration cycle, so where
it does reveal a problem, it will typically make identifying and fixing it
much faster.

This function is still experimental, so please let us know your experiences
and where we could do better:
\url{https://github.com/rstudio/rsconnect/issues/new}
\subsection{Where it helps}{

\code{dryRun()} was motivated by the two most common problems when deploying
your app:
\itemize{
\item The server doesn't install all the packages your app needs to work.
\code{dryRun()} reveals this by using \code{renv::restore()} to create a project
specific library that uses only the packages that are explicitly used
by your project.
\item The server doesn't have environment variables you need. \code{dryRun()}
reveals this by removing any environment variables that you've
set in \verb{~/.Renviron}, except for those that you declare in \code{envVars}.
Additionally, to help debugging it also reports whenever any env var is
used.
}

\code{dryRun} will also log when you use functions that are usually best avoided
in deployed code. This includes:
\itemize{
\item \code{rsconnect::deployApp()} because you shouldn't deploy an app from another
app. This typically indicates that you've included a file with scratch
code.
\item \code{install.packages()} and \code{.libPaths()} because you should rely on the
server to install and manage your packages.
\item \code{browser()}, \code{browseURL()}, and \code{rstudioapi::askForPassword()} because
they need an interactive session that your deployment server will lack.
}
}

\subsection{Current limitations}{
\itemize{
\item \code{dryRun()} currently offers no way to diagnose problems with
mismatched R/Python/Quarto/pandoc versions.
\item \code{dryRun()} doesn't help much with paths. There are two common problems
it can't help with: using an absolute path and using the wrong case.
Both of these will work locally but fail on the server. \code{\link[=lint]{lint()}}
uses an alternative technique (static analysis) to detect many of these
cases.
}
}
}
